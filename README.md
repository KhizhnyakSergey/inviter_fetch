#  *Парсер + инвайтер для телеграмм*


## Использование
- Для парсинга групп
  ```
  python fetch.py
  ```
- Для инвайта
  ```
  python invite.py
  ```


## Иерархия каталогов
```
|—— .venv
|—— .env
|—— inviter
|    |—— .cache
|    |—— config
|        |—— .sessions_config
|            |—— +79108667364_example.json
|        |—— settings.py
|        |—— __init__.py
|    |—— db
|        |—— utils
|            |—— constructors.py
|        |—— __init__.py
|        |—— base.py
|        |—— cache.py
|        |—— core.py
|    |—— issues
|        |—— banned
|        |—— chill
|    |—— models
|        |—— utils
|            |—— constructors.py
|        |—— __init__.py
|        |—— base.py
|        |—— cache.py
|        |—— users.py
|    |—— services
|        |—— fetcher
|            |—— source
|                |—— +447985518465.session
|                |—— +447990047256.session
|            |—— __init__.py
|        |—— inviter
|            |—— source
|                |—— +447985490851.session
|            |—— utils.py
|            |—— __init__.py
|        |—— __init__.py
|        |—— base.py
|    |—— sessions
|        |—— +447990047256.session
|    |—— statistics
|    |—— task_manager
|        |—— __init__.py
|        |—— executor.py
|    |—— telegram
|        |—— utils
|            |—— data.py
|            |—— handlers.py
|            |—— proxy.py
|        |—— __init__.py
|    |—— utils
|        |—— __init__.py
|        |—— error.py
|        |—— logger.py
|    |—— groups_to_fetch.txt
|    |—— groups_to_invite.txt
|    |—— invite.py
|    |—— proxy.txt
|    |—— README.md
|    |—— requirements.txt
|    |—— fetch.py
```

## Установка

Первым делом нужно установить Python 3.10.9

| Python | Скачать | Видео |
| ---     | ---   | ---   |
| Python 3.10.9 | [macOS 64-bit universal2 installer](https://www.python.org/downloads/release/python-3109/) | [установка mac](https://www.youtube.com/watch?v=qNfG4lvpnAc)|
| Python 3.10.9 | [Windows installer (64-bit)](https://www.python.org/downloads/release/python-3109/) | [установка windows](https://www.youtube.com/watch?v=swhlAhKEsG8)|


Сначала нужно распаковать папку с кодом. Потом открыть cmd (командную строку) и перейти в эту директорию. Команда `cd` позволяет перемещаться по папкам.

Для того чтобы узнать путь к папке нажмите правой кнопкой по ней и выберите пункт `Свойства`, далее во вкладке `Общие` вы увидете строку с расположением.

- Пример
    ```sh
    $ cd C:\Users\Сергей\Desktop\freelance
    ```

Создайте виртуальную среду для установки зависимостей и активируйте ее:

> Windows
- Создание 
    ```sh
    $ python -m venv .venv
    ```
- Активация виртуального окружения 
    ```sh
    $ .venv\Scripts\activate
    ```

> Mac 
- Создание 
    ```sh
    $ python3 -m venv .venv
    ```
- Активация виртуального окружения 
    ```sh
    $ source .venv/Scripts/activate
    ```
Обратите внимание на `(.venv)`. Это указывает на то, что этот терминальный сеанс работает в виртуальной среде, которую мы создали.

    
    (.venv) PS C:\Users\Сергей\Desktop\lance>
    
- Далее нам нудно перейти в директорию **inviter**
    ```sh
    (.venv)$ cd inviter
    ```
- Затем установим зависимости
    ```sh
    (.venv)$ pip install -r requirements.txt
    ```

После установки зависимостей у вас будут установлены все необходимые библиотеки для работы программы.  

> Дополнительный шаг если у вас Mac

- нужно дать права файлам такими командами:

    (.venv) user@name-MacBook-Air inviter % chmod u+x fetch.py

    (.venv) user@name-MacBook-Air inviter % chmod u+x invite.py

если вы не видите в своей директории .env и .venv, то нажмите сочетание клавиш:

**Command + Shift + . (точка)**


## Запуск
Файл .env имеет такой вид, если хотите можете изменить их. Здесь просто указываютя названия для файлов.

    DB_NAME=users.db -> указывает название файла БД
    DB_BUFFER_NAME=cache.db -> указывает название файла БД кеша
    PROXY_FILE=proxy.txt -> указывает название файла с проксями
    GROUPS_FOR_INVITE_FILE=groups_to_invite.txt -> указывает название файла с группами для инвайта
    GROUPS_FOR_FETCH_FILE=groups_to_fetch.txt -> указывает название файла с группами для вытаскивания юзеров
    USERS_TXT_FILE=users_men.txt -> файл для добавления юзеров извне (не через парсера), добавит юзеров в базу данных и проверит дубликаты.

### __Парсер__

Перед запуском нужно убедиться что у вас есть сессии в данной директории.
Именно эти сессии будут вытягивать юзеров. 

Пример:

```
|    |—— services
|        |—— base.py
|        |—— fetcher
|            |—— source
|                |—— +447985518465.session
|                |—— +447990047256.session
```
А также в файле `groups_to_fetch.txt` написать группы с которых хотите достать юзеров (он находится в главной директории). Каждая группа на новой строке.


Для запуска с настройками по умолчанию используйте обычный запуск `python fetch.py`

- Windows

    (.venv) PS C:\Users\Сергей\Desktop\freelance\inviter> python fetch.py
- Mac

    (.venv) user@name-MacBook-Air inviter % python3 fetch.py

Вид консоли посде запуска:
```
(.venv) PS C:\Users\Сергей\Desktop\freelance\inviter> python fetch.py
2023-02-26 10:44:26,918 INFO: successfully connected to +447985518465.session session
2023-02-26 10:44:26,960 INFO: joining to public group <group_name>
2023-02-26 10:44:27,290 INFO: successfully join to <group_name>, sleeping for 30
Fetching from <group_name>, letter: , current: 0:  18%|####2                   | 283/1614 [00:14<01:03, 21.00it/s]
```

Вот пример команды для запуска с дополнительными параметрами:
- Windows

```
python fetch.py -t 3 -a true -i 0.05
```

- Mac

```
python3 fetch.py -t 3 -a true -i 0.05
```
В данном примере мы запускаем скрипт и передаем ему три дополнительных параметра:

-t 3 указывает количество задач, которые будут запущены одновременно **(по умолчанию 1)**.

-a True указывает, что мы хотим попытаться получить всех пользователей в группах, даже если в группе больше 10 тысяч участников **(по умолчанию false)**.

-i 0.05 указывает интервал времени между итерациями, которые скрипт выполняет для каждой группы **(по умолчанию 0.02)**.

Можно также использовать другие параметры, которые описаны в функции main(). Для получения полного списка параметров можно использовать флаг -h или --help.

После запуска у вас появится база данных `users.db` и `cache.db`

```
|—— inviter
|    |—— .cache 
|        |—— .cache.db
|    |—— users.db
```

### __Инвайтер__

Перед запуском нужно убедиться что у вас есть сессии в данной директории.

```
|    |—— services
|        |—— inviter
|            |—— source
|                |—— +447985490851.session
```

Эти сессии будут записывать статистику приглашенных юзеров. После выполнения работы инвайтера в папке `statistics` появится файл в таком формате `stat_2023_02_24.txt`, в котором будут записи:

    Группа: group_name
    Было: 11156
    Стало: 12369
    Разница: 1213

В дирестории `sessions` должны лежать сесиии которые будут инвайтить.
``` 
|—— inviter
|    |—— sessions
```


А также в файле `groups_to_invite.txt` написать группы в которые будете добалять юзеров. Каждая группа на новой строке.

Сессии из директории `sessions` будут распределяться поровну на каждую группу.

Пример если у вас будет в файле `groups_to_invite.txt` 3 группы, а в папке  `sessions` будет 15 сессиий, то на каждую группу выйдет по 5 сессий.


Так же как и с парсером вы можете запустить файл `invite.py` с настройками по умолчанию или с использованием дополнительных аргументов.
- Windows

    (.venv)$ python invite.py

- Windows

    (.venv)$ python3 invite.py

При запуске скрипта можно указать следующие аргументы командной строки:

-t, --tasks - количество задач, которые будут выполняться одновременно **(по умолчанию 1)**.

-l, --limit - количество пользователей, которое будет гарантированно приглашено в группу на одну сессию **(по умолчанию 30)**.

-i, --id - если указан, то пользователи будут приглашены по id, но для этого вам нужно использовать сессии которые вытаскивали людей которые находятся по пути `inviter\fetcher\source` и закинуть их в папку `sessions`. Тем самым будет выборка по **id** пользователей без юзернейма со связью сессии которая вытягивала этот аккаунт.

-m, --max_timeout - максимальное время ожидания ответа от сервера Telegram (в секундах) при выполнении каждого запроса **(по умолчанию 8)**.

После отработки скрипта сессии которые инвайтили перемещаются в директории в зависимости от причины. 

```
|    |—— issues
|        |—— banned
|        |—— chill
```

**Чтобы инвайтить в тасках не забудьте добавить Прокси в файл `proxy.txt`. Каждая прокси на новой строке (http://username:password@host:port).**

Пример запуска с параметрами:
- Windows

    python inviter.py --tasks 4 --limit 50 --id true --max_timeout 10

- Mac

    python3 inviter.py --tasks 4 --limit 50 --id true --max_timeout 10


_--tasks 4: количество задач (тасков) для выполнения (опциональный параметр, по умолчанию 1);_

_--limit 50: лимит приглашений (опциональный параметр, по умолчанию 30);_

_--id True: флаг для указания режима приглашения по ID (опциональный параметр, по умолчанию False);_

_--max_timeout 10: максимальное время ожидания ответа сервера (опциональный параметр, по умолчанию 8)._

После запуска любой из команд первым делом в группу присоединяется сессия которая присоединяется и записывает колличество пользователей в группе, для того чтобы после отработки записать статистику. После этого подключаюся сессии с директории `sessions`, которые уже непосредственно приглашают юзеров которых берут с базы данных.

Вид консоли посде запуска:

    (.venv) PS C:\Users\Сергей\Desktop\freelance\inviter> python .\invite.py
    2023-02-26 12:08:27,739 INFO: successfully connected to +447985490851.session session
    2023-02-26 12:08:27,772 INFO: joining to public group <group_name>
    2023-02-26 12:08:27,863 INFO: successfully join to <group_name>, sleeping for 30
    2023-02-26 12:08:57,985 INFO: Checking, members in chat -> grou<group_name>p_name, currently: 11326
    2023-02-26 12:08:57,991 INFO: successfully disconnected from +447985490851.session
    2023-02-26 12:08:59,316 INFO: successfully connected to +447990047256.session session
    2023-02-26 12:08:59,320 INFO: joining to public group <group_name>
    2023-02-26 12:08:59,487 INFO: successfully join to <group_name>, sleeping for 30
    2023-02-26 12:09:29,790 INFO: successfully invited user -> kot_mot_butterbrot
    2023-02-26 12:09:30,935 ERROR: Cant invite user, error occurred -> [UserPrivacyRestrictedError]
    2023-02-26 12:09:37,277 INFO: successfully invited user -> atms_service

## Последующие запуски

Все что вам нужно это активировать вирутальное окружение и запускать скрипт который вам нужен.

## Сессия + json

Если у вас сессии с `json`, то сессии вы закидуете в папку `sessions`, а `json` в следующую директорию.

```
|—— inviter
|    |—— .cache
|    |—— config
|        |—— .sessions_config
|            |—— +79108667364_example.json
```
`+79108667364_example.json` это пример, какие ключи должны находится в этом файле, естественно у сессии и json должен быть один и тот же номер(название).

пример:
```
|—— inviter
|    |—— .cache
|    |—— config
|        |—— .sessions_config
|            |—— +79108667364.json
```

``` 
|—— inviter
|    |—— sessions
|        |—— +79108667364.session
```

При запуске инвайтера скрипт сначала смотрит в `.sessions_config` и если там нет `json` файла сессии, то у `app_id` и `app_hash` будут значения по умолчанию, в противном случае будут подтягиваться значения с `json` файла.


## Описание базы данных

> **Таблица `users` содержит информацию о пользователях. В ней определены следующие поля:**

`username` - строка с никнеймом пользователя. Может быть пустой, индексируется для быстрого поиска.

`first_name` - строка с именем пользователя. Может быть пустой.

`last_name` - строка с фамилией пользователя. Может быть пустой.

`user_id` - целочисленное поле, содержащее идентификатор пользователя. Может быть пустым.

`phone` - строка с номером телефона пользователя. Может быть пустой.

`invite_status` - строка, содержащая текущий статус пользователя. По умолчанию равна "Ready".

`invite_sessions` - связь между пользователями и сессиями приглашений. Одному пользователю может соответствовать множество сессий.

> **Таблица `invited_sessions` содержит информацию о сессиях приглашений. В ней определены следующие поля:**

`session` - строка, содержащая информацию о сессии приглашения. Может быть пустой, индексируется для быстрого поиска.

`access_hash` - целочисленное поле, содержащее хеш-код доступа к сессии. Может быть пустым.

`users` - связь между сессиями приглашений и пользователями. Одной сессии приглашения может соответствовать множество пользователей.


> **Таблица `invited_session_user` содержит информацию о связи между пользователями и сессиями приглашений. В ней определены следующие поля:**

`invited_user_id` - целочисленное поле, содержащее идентификатор пользователя. Ссылается на поле id таблицы users.

`invited_user_session_id` - целочисленное поле, содержащее идентификатор сессии приглашения. Ссылается на поле id таблицы invited_sessions. Комбинация этих двух полей является первичным ключом таблицы invited_session_user.


> **Таблица `groups` имеет следующие столбцы:**

`name` - строковый столбец с необязательным значением, представляющий имя группы. Используется в качестве индекса.

`group_id` - целочисленный столбец с необязательным значением, представляющий идентификатор группы.

`group_hash_id` - целочисленный столбец с необязательным значением, представляющий хэш-идентификатор группы.

`is_private` - булевский столбец, который определяет, является ли группа приватной.

`session` - отношение "один-ко-многим" с таблицей "sessions". Определяет, что каждая группа может иметь много сессий, а каждая сессия относится только к одной группе.


> **Таблица `sessions` имеет следующие столбцы:**

`name` - строковый столбец с необязательным значением, представляющий имя сессии. Используется в качестве индекса.

`group_id` - целочисленный столбец с необязательным значением, представляющий идентификатор группы, к которой принадлежит сессия. Связан с таблицей **groups**.

`groups` - отношение "один-ко-многим" с таблицей "groups". Определяет, что каждая сессия может принадлежать только одной группе, а каждая группа может иметь много сессий.

> В классе **DataBase** реализованы следующие методы:

`create_delete_db(self, create: bool = True) -> None`: метод для создания или удаления базы данных и таблиц, которые представлены в виде объектов в SQLModel. Принимает аргумент create, определяющий создание или удаление.

`set_fetched_users(self, user: AddUserConstructor, session: AddSessionConsctuctor) -> None` - метод для добавления пользователя, полученного из другой базы данных, в текущую базу данных. Если пользователь существует в текущей базе данных, он не добавляется. Метод принимает два аргумента: user - объект класса AddUserConstructor, представляющий пользователя, и session - объект класса AddSessionConstructor, представляющий сессию пользователя.

`get_users_with_session(self, session: str) -> list[InputUser]` - метод для получения списка пользователей, зарегистрированных в заданной сессии. Возвращает список объектов класса InputUser, представляющих пользователей, у которых нет имени пользователя.

`iter_users(self) -> AsyncGenerator[str, Any]` - метод для получения списка имён пользователей из базы данных. Возвращает AsyncGenerator, который по мере выполнения генерирует имена пользователей.

`get_users(self) -> list[str]` - метод для получения списка всех имен пользователей из базы данных. Возвращает список уникальных имен пользователей.

`update_state(self, username: str, status: str) -> None` - метод для обновления состояния пользователя в базе данных. Принимает имя пользователя username и новый статус status. Если пользователь не найден, метод ничего не делает.

`update_state_by_id(self, id_: int, status: str) -> None` - метод для обновления состояния пользователя по ID в базе данных. Принимает id_ пользователя и новый статус status. Если пользователь не найден, метод ничего не делает.

`update_users(self, usernames: list[str], consctructor: AddUserConstructor | None = None) -> None` - метод для обновления списка пользователей в базе данных. Принимает список usernames и необязательный аргумент constructor, который может быть объектом класса AddUserConstructor. Если constructor задан, то метод будет добавлять новых пользователей в базу данных. Если constructor не задан, метод будет обновлять состояние пользователей в базе данных, у которых есть имя пользователя из списка usernames.


> В классе **Cache** реализованы следующие методы:

`create_delete_db(create: bool = True) -> None` - создает или удаляет базу данных. Если create равен True, создает таблицы в базе данных, иначе удаляет их.

`add(session_name: str, data: AddToCache | dict) -> None` - добавляет данные в кэш. session_name - имя сессии, которая добавляет группу. data - данные, которые необходимо добавить в базу данных и ссылки на сессию. Может принимать экземпляр класса AddToCache или словарь.

`delete(session_name: str) -> None` - удаляет данные из базы данных.

`get_hash_id(session_name: str, group_name: str) -> int | None` - получает идентификатор группы для выполнения действий.


## Задача

*  ### __Инвайтер__

    1. Приложение должно быть написано на языке программирования Python с использованием библиотеки Telethon для работы с Telegram API.
    2. Приложение должно иметь возможность инвайта аккаунтов в публичные группы на основе списка, содержащего имена пользователей или ID пользователей.
    3. Приложение должно поддерживать использование нескольких аккаунтов Telegram для инвайта пользователей в публичные группы, чтобы избежать блокировки аккаунта.
    4. Приложение должно иметь возможность использования до 500 потоков для ускорения процесса инвайта.
    5. Приложение должно быть способно автоматически обнаруживать и пропускать уже добавленных пользователей в группу.
    6. Приложение должно иметь возможность запускаться из командной строки и принимать параметры, такие как путь к файлу со списком пользователей и количество потоков, которые будут использоваться для инвайта.
    7. Приложение должно иметь возможность вести логирование процесса инвайта, чтобы было проще отследить ошибки и проблемы в работе.
    8. Приложение должно быть отказоустойчивым и иметь механизмы восстановления работы после возможных сбоев.
    9. Приложение должно быть написано в соответствии с лучшими практиками программирования, включая использование модульного кода, комментариев и документации.
    10. Приложение должно быть написано с учетом возможных ограничений Telegram API и быть совместимо с последней версией Telegram API.
    11. Приложение должно быть документировано и снабжено инструкциями по установке и использованию.


* ### __Парсер__

    1. Функция должна быть написана на языке Python и использовать библиотеку Telethon для работы с Telegram API.
    2. Функция должна быть способна извлекать информацию об аккаунтах Telegram из указанных чатов/каналов. Эта информация может включать имена пользователей, ID пользователей, аватары и другую доступную информацию.
    3. Функция должна иметь возможность фильтровать полученную информацию, чтобы исключить дубликаты, неактивные или заблокированные аккаунты.
    Полученная информация должна сохраняться в базу данных, которую можно использовать для автоматического инвайта аккаунтов в публичные группы.
    4. Функция должна быть способна запускаться из командной строки и принимать параметры, такие как список чатов/каналов, которые будут использоваться для парсинга, и путь к файлу, в который будет сохраняться полученная информация.
    5. Функция должна быть написана с учетом ограничений Telegram API и совместимости с последней версией Telegram API.
    6. Функция должна быть документирована и снабжена инструкциями по использованию.
    7. Эта дополнительная функция поможет создать базу аккаунтов Telegram, которые можно будет использовать для автоматического инвайта в публичные группы. Кроме того, она может значительно упростить процесс сбора информации об аккаунтах и облегчить работу пользователям, которые хотят получить доступ к публичным группам Telegram.
